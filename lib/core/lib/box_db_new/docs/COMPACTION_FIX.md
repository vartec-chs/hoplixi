# Исправление механизма компактификации

## Проблема

Ранее метод `needsCompaction()` проверял только процент записей с флагом `deleted` в индексе. Однако при вызове `update()` старая версия записи оставалась в файле `data.jsonl`, но в индексе обновлялся только номер строки на новую версию. Таким образом:

- **Удалённые записи** (`deleted: true`) учитывались в компактификации
- **Устаревшие версии** от `update()` НЕ учитывались

Это приводило к накоплению "мусора" в файле без автоматической очистки.

## Решение

### 1. Отслеживание общего количества строк в файле

Добавлено поле `_totalLinesInFile` в `IndexManager`:

```dart
class IndexManager {
  Map<String, IndexEntry> _index = {};
  int _totalLinesInFile = 0; // NEW!
  
  void add(String id, int lineNumber) {
    _index[id] = IndexEntry(line: lineNumber, deleted: false);
    _totalLinesInFile++; // Увеличиваем счётчик
  }
  
  void update(String id, int newLineNumber) {
    _index[id] = IndexEntry(line: newLineNumber, deleted: false);
    _totalLinesInFile++; // Новая версия добавляется, старая остаётся
  }
}
```

### 2. Новая логика `needsCompaction()`

Теперь метод сравнивает количество активных записей с общим количеством строк в файле:

```dart
bool needsCompaction({double threshold = 0.3}) {
  if (_totalLinesInFile == 0) return false;
  
  final activeCount = count; // Количество активных записей
  final garbageCount = _totalLinesInFile - activeCount; // Мусор
  final garbageRatio = garbageCount / _totalLinesInFile;
  
  return garbageRatio >= threshold;
}
```

**Мусор** теперь включает:
- Удалённые записи (`deleted: true`)
- Устаревшие версии от `update()`

### 3. Стратегия автокомпактификации

**При `delete()`:**
- Автоматическая компактификация при > 30% мусора (порог по умолчанию)
- Подходит, т.к. delete обычно редкая операция

**При `update()`:**
- Автоматическая компактификация **ОТКЛЮЧЕНА**
- Причина: update может быть частой операцией, компактификация при каждом update была бы неэффективной
- Рекомендация: вызывать `db.compact()` вручную периодически

### 4. Сохранение временных меток при компактификации

Обновлён метод `compact()` в `StorageManager` для сохранения временных меток:

```dart
newIndex[entry.key] = {
  'line': newLineNumber,
  'deleted': false,
  'timestamp': indexData['timestamp'], // Сохраняем!
};
```

## Примеры использования

### Автоматическая компактификация при delete()

```dart
// Вставить 10 записей
for (var i = 0; i < 10; i++) {
  await db.insert(User(id: '$i', ...));
}

// Удалить 4 записи (40% мусора)
for (var i = 0; i < 4; i++) {
  await db.delete('$i');
}
// Автоматически вызывается компактификация (> 30% порог)
```

### Ручная компактификация после множественных update()

```dart
// Вставить запись
await db.insert(User(id: '1', name: 'Alice', ...));

// Многократно обновить
for (var i = 0; i < 100; i++) {
  await db.update(User(id: '1', name: 'Alice v$i', ...));
}
// В файле 101 строка, активная 1

// Вручную очистить мусор
await db.compact();
// Теперь в файле 1 строка
```

### Проверка необходимости компактификации

```dart
// Получить статистику можно через count() и размер файла
final activeCount = await db.count();

// Или просто вызвать компактификацию периодически
Timer.periodic(Duration(hours: 1), (_) async {
  await db.compact();
});
```

## Преимущества

✅ **Правильное определение мусора**: учитываются и удалённые, и устаревшие версии  
✅ **Автоматическая очистка при delete()**: мусор удаляется автоматически  
✅ **Контроль при update()**: пользователь решает, когда компактифицировать  
✅ **Сохранение временных меток**: история не теряется при компактификации  
✅ **Эффективность**: компактификация не вызывается слишком часто  

## Тестирование

Добавлено 5 новых тестов в `test/box_compaction_test.dart`:

1. ✅ Компактификация после множественных update
2. ✅ Компактификация после delete
3. ✅ Сохранение временных меток при компактификации
4. ✅ Определение мусора от update
5. ✅ Компактификация после смешанных операций

**Всего тестов: 73** (все проходят)

## Рекомендации

1. **После множественных update()**: вызывать `db.compact()` вручную
2. **Периодическая компактификация**: раз в час/день в зависимости от нагрузки
3. **Мониторинг размера файла**: сравнивать с `count()` для оценки мусора
4. **Backup перед компактификацией**: всегда создаётся автоматически

## Миграция

Изменения полностью обратно совместимы:
- Существующие БД будут работать без изменений
- При загрузке `_totalLinesInFile` вычисляется из файла
- Все временные метки сохраняются

Не требуется никаких действий для обновления существующих баз данных.
